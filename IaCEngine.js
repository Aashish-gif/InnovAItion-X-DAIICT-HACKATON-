/**
 * Infrastructure as Code Engine
 * Generates Terraform code from React Flow nodes and performs security audits
 */

/**
 * Generates Terraform configuration from React Flow nodes
 * @param {Array} nodes - Array of nodes from React Flow
 * @returns {string} Generated Terraform configuration
 */
function generateTerraform(nodes) {
  if (!nodes || nodes.length === 0) {
    return '# Zenith Ai - No infrastructure nodes defined\n';
  }

  // Enhanced templates map (matching the quality of ragTerraformGenerator)
  const templates = {
    'ec2': (name, label) => `# EC2 Instance: ${label}
resource "aws_instance" "${name}" {
  ami           = var.ec2_ami
  instance_type = var.instance_type

  metadata_options {
    http_endpoint               = "enabled"
    http_tokens                 = "required"
    http_put_response_hop_limit = 2
  }

  root_block_device {
    encrypted = true
    volume_type = "gp3"
  }

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}
`,
    's3': (name, label) => `# S3 Bucket: ${label}
resource "aws_s3_bucket" "${name}" {
  bucket = "${label.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}"

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}

resource "aws_s3_bucket_versioning" "${name}_versioning" {
  bucket = aws_s3_bucket.${name}.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_public_access_block" "${name}_access" {
  bucket = aws_s3_bucket.${name}.id
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource "aws_s3_bucket_server_side_encryption_configuration" "${name}_encryption" {
  bucket = aws_s3_bucket.${name}.id
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}
`,
    'rds': (name, label) => `# RDS Database: ${label}
resource "aws_db_instance" "${name}" {
  identifier        = "${name}-db"
  engine            = "postgres"
  engine_version    = "15"
  instance_class    = var.db_instance_class
  allocated_storage = 20
  storage_type      = "gp3"
  db_name           = var.db_name
  username          = var.db_username
  password          = var.db_password
  
  skip_final_snapshot = true
  deletion_protection = false

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}
`
  };

  let terraformCode = `# Generated by Zenith Ai
# Modern Infrastructure as Code Practices (2026)

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.40"
    }
  }
  required_version = ">= 1.8"
}

provider "aws" {
  region = var.aws_region
  default_tags {
    tags = {
      ManagedBy = "Zenith Ai"
      Terraform = "true"
    }
  }
}

`;

  // Process each node
  nodes.forEach((node, index) => {
    const nodeId = (node.id || `resource_${index}`).replace(/[^a-z0-9_]/g, '_');
    const nodeType = (node.type || node.data?.type || '').toLowerCase();
    const nodeLabel = node.data?.label || nodeId;

    if (templates[nodeType]) {
      terraformCode += templates[nodeType](nodeId, nodeLabel) + '\n';
    } else {
      terraformCode += `# Unknown node type: ${nodeType} (${nodeLabel})\n\n`;
    }
  });

  // Add variables block
  terraformCode += '# Variables\n';
  terraformCode += 'variable "aws_region" {\n  description = "AWS region"\n  type        = string\n  default     = "us-east-1"\n}\n\n';
  terraformCode += 'variable "ec2_ami" {\n  description = "AMI ID for EC2 instances"\n  type        = string\n  default     = "ami-0c55b159cbfafe1f0" # Replace with latest AL2023\n}\n\n';
  terraformCode += 'variable "instance_type" {\n  description = "EC2 instance type"\n  type        = string\n  default     = "t3.micro"\n}\n\n';
  terraformCode += 'variable "db_instance_class" {\n  description = "RDS instance class"\n  type        = string\n  default     = "db.t3.micro"\n}\n\n';
  terraformCode += 'variable "db_name" {\n  description = "RDS database name"\n  type        = string\n  default     = "mydb"\n}\n\n';
  terraformCode += 'variable "db_username" {\n  description = "RDS master username"\n  type        = string\n  default     = "admin"\n}\n\n';
  terraformCode += 'variable "db_password" {\n  description = "RDS master password"\n  type        = string\n  sensitive   = true\n}\n';

  return terraformCode;
}

/**
 * Processes a project from MongoDB and generates Terraform code
 * @param {Object} project - The project object from MongoDB
 * @returns {Object} Object containing generated Terraform code and metadata
 */
function processProjectFromDB(project) {
  if (!project || !project.nodes) {
    return {
      success: false,
      error: 'Invalid project data: missing nodes',
      terraformCode: null
    };
  }

  try {
    // Extract nodes from the project
    const nodes = project.nodes;

    // Generate Terraform code from nodes
    const terraformCode = generateTerraform(nodes);

    return {
      success: true,
      terraformCode: terraformCode,
      projectName: project.projectName,
      nodeIdCount: Array.isArray(nodes) ? nodes.length : 0,
      createdAt: project.createdAt,
      updatedAt: project.updatedAt
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
      terraformCode: null
    };
  }
}

/**
 * Runs a security audit on the generated Terraform code
 * @param {string} code - The Terraform code string to audit
 * @returns {Object} Security audit results with warnings
 */
function runSecurityAudit(code) {
  const warnings = [];
  const errors = [];

  // Check for open security groups (0.0.0.0/0)
  if (code.includes('0.0.0.0/0')) {
    warnings.push({
      level: 'HIGH',
      type: 'SECURITY_GROUP',
      message: 'High-risk security issue detected: Open security group rule (0.0.0.0/0) allows access from anywhere on the internet',
      recommendation: 'Restrict CIDR blocks to specific IP ranges or use security group references instead of 0.0.0.0/0'
    });
  }

  return {
    hasIssues: warnings.length > 0 || errors.length > 0,
    warnings: warnings,
    errors: errors,
    summary: {
      totalIssues: warnings.length + errors.length,
      highRisk: warnings.filter(w => w.level === 'HIGH').length,
      mediumRisk: warnings.filter(w => w.level === 'MEDIUM').length,
      lowRisk: warnings.filter(w => w.level === 'LOW').length
    }
  };
}

// Export functions
export { generateTerraform, runSecurityAudit, processProjectFromDB };



