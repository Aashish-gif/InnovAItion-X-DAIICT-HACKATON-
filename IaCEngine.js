/**
 * Infrastructure as Code Engine
 * Generates Terraform code from React Flow nodes and performs security audits
 */

/**
 * Generates Terraform configuration from React Flow nodes
 * @param {Array} nodes - Array of nodes from React Flow
 * @returns {string} Generated Terraform configuration
 */
function generateTerraform(nodes) {
  if (!nodes || nodes.length === 0) {
    return '';
  }

  // Enhanced templates map (matching the quality of ragTerraformGenerator)
  const templates = {
    'ec2': (name, label) => `# EC2 Instance: ${label}
resource "aws_instance" "${name}" {
  ami           = var.ec2_ami
  instance_type = var.instance_type

  metadata_options {
    http_endpoint               = "enabled"
    http_tokens                 = "required"
    http_put_response_hop_limit = 2
  }

  root_block_device {
    encrypted = true
    volume_type = "gp3"
  }

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}
`,
    's3': (name, label) => `# S3 Bucket: ${label}
resource "aws_s3_bucket" "${name}" {
  bucket = "${label.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}"

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}

resource "aws_s3_bucket_versioning" "${name}_versioning" {
  bucket = aws_s3_bucket.${name}.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_public_access_block" "${name}_access" {
  bucket = aws_s3_bucket.${name}.id
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource "aws_s3_bucket_server_side_encryption_configuration" "${name}_encryption" {
  bucket = aws_s3_bucket.${name}.id
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}
`,
    'rds': (name, label) => `# RDS Database: ${label}
resource "aws_db_instance" "${name}" {
  identifier        = "${name}-db"
  engine            = "postgres"
  engine_version    = "15"
  instance_class    = var.db_instance_class
  allocated_storage = 20
  storage_type      = "gp3"
  db_name           = var.db_name
  username          = var.db_username
  password          = var.db_password
  
  skip_final_snapshot = true
  deletion_protection = false
  publicly_accessible = false

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}
`,
    'lambda': (name, label) => `# Lambda Function: ${label}
resource "aws_lambda_function" "${name}" {
  function_name = "${label.toLowerCase().replace(/\s+/g, '-')}"
  role          = aws_iam_role.lambda_role.arn
  handler       = "index.handler"
  runtime       = "python3.13"

  filename         = "lambda_function.zip"
  source_code_hash = filebase64sha256("lambda_function.zip")

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}

resource "aws_iam_role" "lambda_role" {
  name = "lambda-${name}-role"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{ Action = "sts:AssumeRole", Effect = "Allow", Principal = { Service = "lambda.amazonaws.com" } }]
  })
}
`,
    'vpc': (name, label) => `# VPC: ${label}
resource "aws_vpc" "${name}" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "${label}"
    ManagedBy   = "Zenith Ai"
    Terraform   = "true"
  }
}
`
  };

  let terraformCode = `# Generated by Zenith Ai
# Modern Infrastructure as Code Practices (2026)

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.40"
    }
  }
  required_version = ">= 1.8"
}

provider "aws" {
  region = var.aws_region
  default_tags {
    tags = {
      ManagedBy = "Zenith Ai"
      Terraform = "true"
    }
  }
}

`;

  // Process each node
  nodes.forEach((node, index) => {
    const nodeId = (node.id || `resource_${index}`).replace(/[^a-z0-9_]/g, '_');
    const nodeType = (node.type || (node.data && node.data.type) || '').toLowerCase();
    const nodeLabel = (node.data && node.data.label) || nodeId;

    if (templates[nodeType]) {
      terraformCode += templates[nodeType](nodeId, nodeLabel) + '\n';
    } else {
      terraformCode += `# Unknown node type: ${nodeType} (${nodeLabel})\n\n`;
    }
  });

  // Add variables block
  terraformCode += '# Variables\n';
  terraformCode += 'variable "aws_region" {\n  description = "AWS region"\n  type        = string\n  default     = "us-east-1"\n}\n\n';
  terraformCode += 'variable "ec2_ami" {\n  description = "AMI ID for EC2 instances"\n  type        = string\n  default     = "ami-0c55b159cbfafe1f0" # Replace with latest AL2023\n}\n\n';
  terraformCode += 'variable "instance_type" {\n  description = "EC2 instance type"\n  type        = string\n  default     = "t3.micro"\n}\n\n';
  terraformCode += 'variable "db_instance_class" {\n  description = "RDS instance class"\n  type        = string\n  default     = "db.t3.micro"\n}\n\n';
  terraformCode += 'variable "db_name" {\n  description = "RDS database name"\n  type        = string\n  default     = "mydb"\n}\n\n';
  terraformCode += 'variable "db_username" {\n  description = "RDS master username"\n  type        = string\n  default     = "admin"\n}\n\n';
  terraformCode += 'variable "db_password" {\n  description = "RDS master password"\n  type        = string\n  sensitive   = true\n}\n';

  return terraformCode;
}

/**
 * Processes a project from MongoDB and generates Terraform code
 * @param {Object} project - The project object from MongoDB
 * @returns {Object} Object containing generated Terraform code and metadata
 */
function processProjectFromDB(project) {
  if (!project || !project.nodes) {
    return {
      success: false,
      error: 'Invalid project data: missing nodes',
      terraformCode: null
    };
  }

  try {
    // Extract nodes from the project
    const nodes = project.nodes;

    // Generate Terraform code from nodes
    const terraformCode = generateTerraform(nodes);

    return {
      success: true,
      terraformCode: terraformCode,
      projectName: project.projectName,
      nodeIdCount: Array.isArray(nodes) ? nodes.length : 0,
      createdAt: project.createdAt,
      updatedAt: project.updatedAt
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
      terraformCode: null
    };
  }
}

/**
 * Runs a security audit on the generated Terraform code
 * @param {string} code - The Terraform code string to audit
 * @returns {Object} Security audit results with warnings
 */
function runSecurityAudit(code) {
  const warnings = [];
  const errors = [];

  // Check for open security groups (0.0.0.0/0)
  if (code.includes('0.0.0.0/0')) {
    warnings.push({
      level: 'HIGH',
      type: 'SECURITY_GROUP',
      message: 'Open security group rule detected: (0.0.0.0/0) allows access from anywhere on the internet.',
      recommendation: 'Restrict CIDR blocks to specific IP ranges or use security group references.'
    });
  }

  // Check for public S3 buckets
  if (code.includes('acl = "public-read"') || code.includes('acl = "public-read-write"')) {
    warnings.push({
      level: 'CRITICAL',
      type: 'S3_BUCKET',
      message: 'Publicly accessible S3 bucket detected.',
      recommendation: 'Change ACL to "private" and use CloudFront or Bucket Policies for controlled access.'
    });
  }

  // Check for unencrypted volumes
  if (code.includes('aws_instance') && !code.includes('encrypted = true')) {
    warnings.push({
      level: 'MEDIUM',
      type: 'EC2_STORAGE',
      message: 'Unencrypted EBS volumes detected for EC2 instance.',
      recommendation: 'Enable EBS encryption at the account level or specifically for each volume block.'
    });
  }

  // Check for public RDS
  if (code.includes('publicly_accessible = true')) {
    warnings.push({
      level: 'HIGH',
      type: 'RDS_EXPOSURE',
      message: 'RDS database is set to publicly accessible.',
      recommendation: 'Set publicly_accessible = false and use a VPN or Bastion host for administrative access.'
    });
  }

  // Check for IAM wildcard permissions
  if (code.includes('"Action": "*"') || code.includes('"Action": ["*"]') || code.includes('Action = "*"')) {
    warnings.push({
      level: 'HIGH',
      type: 'IAM_WILDCARD',
      message: 'IAM policy with wildcard permissions detected.',
      recommendation: 'Follow the principle of least privilege and specify only the required actions.'
    });
  }

  return {
    hasIssues: warnings.length > 0 || errors.length > 0,
    warnings: warnings,
    errors: errors,
    summary: {
      totalIssues: warnings.length + errors.length,
      highRisk: warnings.filter(w => w.level === 'HIGH' || w.level === 'CRITICAL').length,
      mediumRisk: warnings.filter(w => w.level === 'MEDIUM').length,
      lowRisk: warnings.filter(w => w.level === 'LOW').length
    }
  };
}

// Export functions
export { generateTerraform, runSecurityAudit, processProjectFromDB };



